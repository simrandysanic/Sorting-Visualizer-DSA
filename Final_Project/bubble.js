let audioCtx = null;

// Function to play sound during sorting
function playNote(freq) {
    if (audioCtx == null) {
        audioCtx = new (AudioContext || webkitAudioContext || window.webkitAudioContext)();
    }
    const dur = 0.1;
    const osc = audioCtx.createOscillator();
    osc.frequency.value = freq;
    osc.start();
    osc.stop(audioCtx.currentTime + dur);
    const node = audioCtx.createGain();
    node.gain.value = 0.1;
    node.gain.linearRampToValueAtTime(0, audioCtx.currentTime + dur);
    osc.connect(node);
    node.connect(audioCtx.destination);
}

// GLOBAL VARIABLES
let s = 600; // Default speed (600 ms)
let n = 25; // Default number of elements
let array = [];
let isAnimating = false; // To track animation state
let swapCount = 0; // To track number of swaps
let animationId; // ID to track the current animation
let remainingSwaps = []; // To store swaps generated by bubble sort

// Initialize with random array by default
initRandom();

// FUNCTIONS

// Function to stop ongoing animation and reset everything
function stopCurrentAnimation() {
    isAnimating = false;
    enableButtons();
    clearTimeout(animationId); // Clear any ongoing timeout
}

// Function to initialize a random array
function initRandom() {
    stopCurrentAnimation(); // Stop any ongoing animation
    array = [];
    for (let i = 0; i < n; i++) {
        array.push(Math.random());
    }
    showBars(); // Display the bars
    resetSwapCounter(); // Reset swap counter
    updateElementCountDisplay(); // Update UI for number of elements
    updateStatusMessage("Initialized with a Random array.");
}

// Function to initialize the worst-case scenario (reverse sorted array)
function initWorst() {
    stopCurrentAnimation(); // Stop any ongoing animation
    array = [];
    for (let i = n; i > 0; i--) {
        array.push(i / n);
    }
    showBars(); // Display the bars
    resetSwapCounter(); // Reset swap counter
    updateElementCountDisplay(); // Update UI for number of elements
    updateStatusMessage("Initialized with the Reverse Sorted array.");
}

// Function to initialize the best-case scenario (already sorted array)
function initBest() {
    stopCurrentAnimation(); // Stop any ongoing animation
    array = [];
    for (let i = 1; i <= n; i++) {
        array.push(i / n);
    }
    showBars(); // Display the bars
    resetSwapCounter(); // Reset swap counter
    updateElementCountDisplay(); // Update UI for number of elements
    updateStatusMessage("Initialized with the Sorted array.");
}

// Function to play the bubble sort animation
function playBubbleSort() {
    if (isAnimating) return; // Do nothing if already animating
    isAnimating = true;

    if (remainingSwaps.length === 0) {
        swapCount = 0; // Reset swap counter
        const copy = [...array]; // Copy the array for sorting
        remainingSwaps = bubbleSort(copy); // Generate the swaps
        updateStatusMessage("Starting Bubble Sort...");
    }

    disableButtons(); // Disable buttons during sorting
    animate(remainingSwaps); // Start the animation
}

// Function to stop the animation
function stopAnimation() {
    stopCurrentAnimation();
    updateStatusMessage("Animation stopped.");
}

// Function to animate the sorting process
function animate(swaps) {
    if (swaps.length === 0) {
        stopAnimation();
        colorSortedBars(); // Color bars green to indicate sorting is done
        updateStatusMessage("Sorting complete!");
        return;
    }

    const [i, j] = swaps.shift(); // Get next swap
    [array[i], array[j]] = [array[j], array[i]]; // Perform the swap
    swapCount++; // Increment swap counter
    updateSwapCounter(); // Update UI for swap counter

    // Play sound based on the value of the swapped elements
    playNote(200 + array[i] * 500);
    playNote(200 + array[j] * 500);

    showBars(i, j); // Re-render the bars with the swapped elements highlighted
    updateStatusMessage(`Swapped elements at index ${i} and ${j}.`);

    // Continue the animation with a delay based on speed
    animationId = setTimeout(() => {
        animate(swaps);
    }, s);
}

function bubbleSort(arr) {
    const swaps = [];
    let swapped;
    for(let i =0;i<arr.length - 1;i++)
    {
        swapped = false;
        for (let j = 0; j < arr.length - 1-i; j++) {
            if (arr[j] > arr[j + 1]) {
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                swaps.push([j, j + 1]);
                swapped = true;
            }
        }
        if (swapped == false)
            break;
    }
   
    return swaps;
}

// Function to display the bars in the container
function showBars(activeIndex1 = -1, activeIndex2 = -1) {
    const container = document.getElementById("container");
    container.innerHTML = "";

    const barWidth = Math.max(5, Math.floor(container.clientWidth / n)); // Bar width based on number of elements
    const maxValue = Math.max(...array); // Get the maximum value in the array
    const barMaxHeight = 90; // Maximum height for bars

    for (let i = 0; i < array.length; i++) {
        const bar = document.createElement("div");
        bar.style.position = "absolute";
        bar.style.bottom = "0";
        bar.style.height = `${(array[i] / maxValue) * barMaxHeight}%`; // Height proportional to array value
        bar.style.width = barWidth + "px";
        bar.classList.add("bar");
        bar.style.backgroundColor = (activeIndex1 === i || activeIndex2 === i) ? "red" : "#5d5d77"; // Highlight swapped bars
        bar.style.left = `${i * (barWidth + 1)}px`; // Position bars horizontally
        container.appendChild(bar);

        // Display value on top of the bar
        const numberSpan = document.createElement("span");
        numberSpan.innerText = Math.floor(array[i] * 100); // Display the integer value
        numberSpan.style.fontSize = "12px";
        numberSpan.style.position = "absolute";
        numberSpan.style.left = `${i * (barWidth + 1) + barWidth / 2}px`;
        numberSpan.style.transform = "translateX(-50%)";
        numberSpan.style.bottom = `${(array[i] / maxValue) * barMaxHeight + 2}%`;
        container.appendChild(numberSpan);
    }

    container.style.height = "350px"; // Ensure container height
}

// Function to color all bars green to indicate sorted state
function colorSortedBars() {
    const bars = document.getElementsByClassName("bar");
    for (let i = 0; i < bars.length; i++) {
        bars[i].style.backgroundColor = "#96CEB4";
    }
}

// Utility function to update swap counter UI
function updateSwapCounter() {
    const swapDisplay = document.getElementById("swapCounter");
    swapDisplay.innerText = `Swaps: ${swapCount}`;
}

// Utility function to reset swap counter
function resetSwapCounter() {
    swapCount = 0;
    updateSwapCounter();
}

// Utility function to update number of elements display
function updateElementCountDisplay() {
    const elementCountDisplay = document.getElementById("elementCount");
    elementCountDisplay.innerText = `Number of Elements: ${n}`;
}

// Utility function to update status message display
function updateStatusMessage(message) {
    const statusMessage = document.getElementById("statusMessage");
    statusMessage.innerText = message;
}

// Utility function to disable all control buttons during animation
function disableButtons() {
    document.getElementById("randomArray").disabled = true;
    document.getElementById("worstCaseArray").disabled = true;
    document.getElementById("bestCaseArray").disabled = true;
    document.getElementById("playButton").disabled = true;
    document.getElementById("stopButton").style.display = "inline";
    document.getElementById("elementsRange").disabled = true;
    document.getElementById("speedRange").disabled = true;
}

// Utility function to enable all control buttons after animation
function enableButtons() {
    document.getElementById("randomArray").disabled = false;
    document.getElementById("worstCaseArray").disabled = false;
    document.getElementById("bestCaseArray").disabled = false;
    document.getElementById("playButton").disabled = false;
    document.getElementById("stopButton").style.display = "none";
    document.getElementById("elementsRange").disabled = false;
    document.getElementById("speedRange").disabled = false;
}

// Event Listeners
document.getElementById("randomArray").addEventListener("click", initRandom);
document.getElementById("worstCaseArray").addEventListener("click", initWorst);
document.getElementById("bestCaseArray").addEventListener("click", initBest);
document.getElementById("playButton").addEventListener("click", playBubbleSort);
document.getElementById("stopButton").addEventListener("click", stopAnimation);

// Slider to adjust the number of elements (bars) in the array
document.getElementById("elementsRange").addEventListener("input", function() {
    n = parseInt(this.value);
    initRandom(); // Reinitialize the array with the new element count
    updateElementCountDisplay();
});

// Slider to adjust the animation speed
document.getElementById("speedRange").addEventListener("input", function() {
    s = 1100 - parseInt(this.value); // Invert the delay calculation
});


